"""
Benchmark class, for interfacing between mtgindex and mtgjson databases.
"""
import warnings
import json


class Benchmark:
    """Interface between mtgjson and mtgindex databases by grouping and evaluation of benchmark constituents.
    Tracks constituent selection criteria along with constituent IDs and evaluations for given day.
    Evaluation type can vary depending if benchmark is Paper or Foil or MTGO etc.

    Attributes
    ----------
    name : str
        Name or other ID of benchmark.

    criteria : str
        SQL query used to select relevant constituents from database.

    evaluation_date : str
        Date to retrieve evaluation information for benchmark constituents

    evaluation_type : str
        Type of evaluation to consider when accessing constituent evaluations (i.e. Paper vs Foil vs MTGO)

    constituents : list[str], shape(<num_entries>)
            List of benchmark constituent UUIDs from the mtgjson database.
            Initialises as empty list.

    values : list[str], shape(<num_entries>)
        List of benchmark constituent values from the mtgjson database.
        Initialises as empty list.

    Methods
    -------
    apply_criteria(self, constituent_table_curr) --> Applies benchmark criteria to select valid constituents.
    evaluate_constituents(self, evaluation_table_curr) --> Looks up evaluations of valid constituents.
    report_data(self) --> Returns select benchmark attributes as dictionary.
    get_constituents_str(self) --> Returns constituent list as string
    get_values_str(self) --> Returns constituent list as string
    """

    def __init__(self, name, criteria, evaluation_type, evaluation_date):
        """
        Parameters
        ----------
        name : str
            Name or other ID of benchmark.
            
        criteria : str
            SQL query used to select relevant constituents from database.

        evaluation_type : str
            Type of evaluation to consider when accessing constituent evaluations (i.e. Paper vs Foil vs MTGO)
            
        evaluation_date : str
            Date to retrieve evaluation information for benchmark constituents
        """
        self.name = name
        self.criteria = criteria
        self.evaluation_type = evaluation_type
        self.evaluation_date = evaluation_date
        self.constituents = []
        self.values = []
        self.index_value = None
        self.prior_index_value = None
        self._constituent_weights = []
        self._index_init_value = 1000.0
        self._null_index_value = -1

    def apply_criteria(self, constituent_table_curr):
        """Apply benchmark criteria to table of constituents.
        Filters constituents based on SQL query passed at initialisation.
        If no constituents found then UserWarning is raised.
        Updates `constituents` attribute.

        Parameters
        ----------
        constituent_table_curr : sqlite3.Cursor
            Cursor object for the database containing constituent meta data for selection criteria.

        Returns
        -------
        None
        """
        results = constituent_table_curr.execute(self.criteria).fetchall()
        if len(results) > 0:
            self.constituents = [entry[0] for entry in results]
        else:
            warnings.warn(F'No constituents satisfying criteria {self.criteria}', UserWarning)

    def _evaluation_query(self):
        """Generates SQL query used to parse prices table for constituent value information.
        Query wil filter constituents based on date, constituents and type of value to retrieve.
        Type is specified as can have Foil / Online / Paper versions of cards with different evaluations.

        Returns
        -------
        query : str
            Autogenerated SQL query to parse specific constituent values.
        """
        placeholder = '?'
        cons_placeholder = ",".join(placeholder * len(self.constituents))
        query = F'SELECT price FROM prices WHERE type="{self.evaluation_type}" AND date="{self.evaluation_date}" ' \
                F'AND uuid IN ({cons_placeholder})'
        return query

    def evaluate_constituents(self, evaluation_table_curr):
        """Retrieve the values of benchmark constituents from evaluation table.
        Constituents evaluated according to date, constituents, and `_evaluation_type`.
        If no values are found then raises UserWarning.

        Parameters
        ----------
        evaluation_table_curr : sqlite3.Cursor
            Cursor object for the database containing constituent evaluation data.
        Returns
        -------
        None
        """
        query = self._evaluation_query()
        evaluation_table_curr.execute(query, (self.constituents))
        results = evaluation_table_curr.fetchall()

        if len(results) > 0:
            self.values = [entry[0] for entry in results]
        else:
            warnings.warn(F'No values found', UserWarning)

    def get_prior_index(self, mtgindex_curr):
        """Retrieve first valid prior evaluation of index level from mtgindex database.
        If there are no evaluations for the benchmark constituents on `evaluation_date` then propagate NULL value.
        If there are no existing values then set benchmark level to `_index_init_value`.
        Set the benchmark level to the most recent non-NULL index value.
        If a non-NULL benchmark value has not yet been found then the benchmark will be initialised
        with `_index_init_value` to ensure a value is presnt the next time the benchmark is evaluated.

        Parameters
        ----------
        mtgindex_curr : sqlite3.Cursor
            Cursor object for the database containing index evaluation data.

        Returns
        -------
        None
        """
        if len(self.values) == 0:
            self.prior_index_value = self._null_index_value  # if no valid constituents then just propagate value

        else:
            query = F'SELECT indexvalue from {self.name}'
            query_results = mtgindex_curr.execute(query).fetchall()

            if len(query_results) == 0:
                self.prior_index_value = self._index_init_value  # new benchmark so initialise appropriately

            else:
                for entry in query_results[::-1]:  # loop in reverse order to find most recent
                    entry_value = entry[0]

                    if entry_value != self._null_index_value:  # first non null value
                        self.prior_index_value = entry_value
                        break

                if self.prior_index_value is None:  # catches where only prior propagated values
                    self.prior_index_value = self._index_init_value

    def weight_constituents(self, custom_weighting=None):
        return NotImplemented

    def calculate_index_level(self, custom_weighting=None):
        return NotImplemented

    def get_constituents_str(self):
        """Getter for `constituents`.
        List converted to string via `json.dumps`.
        Intended for interfacing with database.

        Returns
        -------
        `constituents` : str
            List of benchmark constituent UUIDs from the mtgjson database.
            Serialised  into string using json module.
        """
        constituents = json.dumps(self.constituents)
        return constituents

    def get_values_str(self):
        """Getter for `values`.
        List converted to string via `json.dumps`.
        Intended for interfacing with database.

        Returns
        -------
        `values` : str
            List of benchmark constituent values from the mtgjson database.
            Serialised  into string using json module.
        """
        values = json.dumps(self.values)
        return values


# ----------------------------------------------------------------------------------------------------------------------

class PriceWeightedBenchmark(Benchmark):

    def weight_constituents(self, custom_weighting=None):
        """Calculate Price weighting of each evaluated constituent.
        Weighting is calculated as ratio of each constituent's price against the total price of all constituents.
        Custom weights can be passed by user so long as the number of weights matches the number of constituent values.

        Parameters
        ----------
        custom_weighting = list[float], shape(len(self.constituents))
            Weightings for each priced constituent.

        Returns
        -------
        None
        """
        if not custom_weighting:
            total = sum(self.values)
            weights = [price/total for price in self.values]
        else:
            assert len(custom_weighting) == len(self.constituents)
            weights = custom_weighting

        self._constituent_weights = weights

    def calculate_index_level(self, custom_calculator=None):
        """Calculates the price weighted index level of a benchmark using the methodology:
        $$level_t = level_{t-1} \times (1 + \sum_{i=0} c_i \cdot w_i)$$

        Custom calculators can be passed by the user but they must accept specific inputs

        Parameters
        ----------
        custom_calculator : function(prices, weights, prior_level)
            Custom user function to calculate the price weighted index level.

        Returns
        -------
        None.
        """
        if not custom_calculator:
            weighted_prices = sum((p * w for p, w in zip(self.values, self._constituent_weights)))
            new_level = self.prior_index_value * (1 + weighted_prices)
        else:
            new_level = custom_calculator(prices=self.values,
                                          weights=self._constituent_weights,
                                          prior=self.prior_index_value)
        self.index_value = new_level
